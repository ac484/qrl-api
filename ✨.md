---

## ä¸€å¥è©±ç¸½çµç†æƒ³ç‹€æ…‹

> **Domain å®Œå…¨ä¸çŸ¥é“ FastAPI / Redis / Supabase / HTTP / WebSocket çš„å­˜åœ¨**
> **Application ç·¨æ’ç”¨ä¾‹**
> **Infrastructure åªè² è²¬æŠ€è¡“å¯¦ä½œ**
> **Interfaces åªè² è²¬ I/O èˆ‡å‚³è¼¸**

---

# ç†æƒ³åˆ†å±¤ç¸½è¦½ï¼ˆè²¬ä»»ç”±å…§åˆ°å¤–ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Interfaces          â”‚  â† FastAPI / WS / REST / CLI
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Application         â”‚  â† Use Cases / Services / Orchestration
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Domain           â”‚  â† Business Truth
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Infrastructure      â”‚  â† Redis / MEXC / Supabase / HTTP
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¾è³´åªèƒ½ã€Œå¾€å…§ã€**
`Interfaces â†’ Application â†’ Domain`
`Infrastructure â†’ Domain (é€éä»‹é¢)`

---

# ä½ çš„å¯¦éš›ç›®éŒ„ã€Œç†æƒ³å½¢æ…‹ã€

```text
src/app/
â”œâ”€â”€ domain/                # ğŸ”´ çµ•å°ç´”ç²¹
â”‚   â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ value_objects/
â”‚   â”œâ”€â”€ aggregates/
â”‚   â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ events/
â”‚   â”œâ”€â”€ repositories.py    # interface only
â”‚   â””â”€â”€ errors.py
â”‚
â”œâ”€â”€ application/           # ğŸŸ  ç”¨ä¾‹ç·¨æ’
â”‚   â”œâ”€â”€ use_cases/
â”‚   â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ dtos/
â”‚   â”œâ”€â”€ commands/
â”‚   â”œâ”€â”€ queries/
â”‚   â””â”€â”€ ports.py           # outbound ports
â”‚
â”œâ”€â”€ infrastructure/        # ğŸŸ¡ æŠ€è¡“å¯¦ä½œ
â”‚   â”œâ”€â”€ mexc/
â”‚   â”‚   â”œâ”€â”€ http_client.py
â”‚   â”‚   â”œâ”€â”€ ws_client.py
â”‚   â”‚   â”œâ”€â”€ signer.py
â”‚   â”‚   â””â”€â”€ adapters.py
â”‚   â”œâ”€â”€ redis/
â”‚   â”‚   â”œâ”€â”€ client.py
â”‚   â”‚   â””â”€â”€ cache_repo.py
â”‚   â”œâ”€â”€ supabase/
â”‚   â”‚   â”œâ”€â”€ client.py
â”‚   â”‚   â””â”€â”€ user_repo.py
â”‚   â””â”€â”€ persistence/
â”‚
â”œâ”€â”€ interfaces/            # ğŸŸ¢ å‚³è¼¸å±¤
â”‚   â”œâ”€â”€ http/
â”‚   â”‚   â”œâ”€â”€ routes.py
â”‚   â”‚   â”œâ”€â”€ schemas.py     # Pydantic
â”‚   â”‚   â””â”€â”€ deps.py
â”‚   â”œâ”€â”€ websocket/
â”‚   â””â”€â”€ background/
â”‚
â””â”€â”€ shared/                # âšª è·¨å±¤å…±ç”¨
    â”œâ”€â”€ config.py
    â”œâ”€â”€ time.py
    â”œâ”€â”€ logging.py
    â””â”€â”€ utils.py
```

---

# æ¯ä¸€å±¤ã€Œå¯ä»¥ / ä¸å¯ä»¥ã€åšçš„äº‹ï¼ˆé‡é»ï¼‰

## ğŸ”´ Domainï¼ˆæœ€é‡è¦ï¼‰

### å¯ä»¥

* Entity / Aggregate
* Business Rule
* Domain Event
* Repository Interfaceï¼ˆæŠ½è±¡ï¼‰

### âŒ çµ•å°ä¸å¯ä»¥

* `fastapi`
* `redis`
* `supabase`
* `httpx`
* `protobuf`
* `websockets`
* `pydantic`

```python
# domain/repositories.py
from abc import ABC, abstractmethod

class OrderRepository(ABC):
    @abstractmethod
    async def save(self, order): ...
```

---

## ğŸŸ  Applicationï¼ˆç³»çµ±ç”¨ä¾‹ï¼‰

### å¯ä»¥

* Use Case
* ä»»å‹™æµç¨‹ï¼ˆä¾‹å¦‚ï¼šä¸‹å–® â†’ ç­‰å›å ± â†’ å¿«å–ï¼‰
* DTO
* Transaction boundary
* Port å®šç¾©

### âŒ ä¸å¯ä»¥

* ç›´æ¥ç”¨ redis / supabase client
* ç›´æ¥å‘¼å« mexc API

```python
class PlaceOrderUseCase:
    def __init__(self, order_repo, exchange_port):
        ...
```

---

## ğŸŸ¡ Infrastructureï¼ˆæŠ€è¡“åœ°ç„ï¼‰

### å¯ä»¥

* **å¯¦ä½œ** Repository
* å‘¼å« MEXC API
* Redis Cache
* Supabase å­˜å–
* protobuf decode

### âŒ ä¸å¯ä»¥

* å•†æ¥­é‚è¼¯
* if / else æ±ºç­–è¦å‰‡

```python
class RedisOrderRepository(OrderRepository):
    async def save(self, order):
        await self.redis.set(...)
```

---

## ğŸŸ¢ Interfacesï¼ˆä¸–ç•Œå…¥å£ï¼‰

### å¯ä»¥

* FastAPI Router
* WebSocket handler
* Request / Response Schema
* Auth / Dependency

### âŒ ä¸å¯ä»¥

* å•†æ¥­é‚è¼¯
* è³‡æ–™åº«é‚è¼¯

```python
@router.post("/orders")
async def place_order(cmd: PlaceOrderRequest):
    await use_case.execute(cmd)
```

---

## âšª Sharedï¼ˆå¾ˆå®¹æ˜“æ¿«ç”¨ï¼‰

### åªèƒ½æ”¾

* config
* logging
* time
* serializer
* retry / backoff

âŒ **ä¸èƒ½æ”¾**

* æ¥­å‹™è¦å‰‡
* Entity
* Repository

---

# å¥—ä»¶å°æ‡‰ã€Œæ‡‰è©²å‡ºç¾åœ¨å“ªä¸€å±¤ã€

| å¥—ä»¶           | å±¤                        |
| ------------ | ------------------------ |
| fastapi      | interfaces               |
| pydantic     | interfaces / application |
| httpx        | infrastructure           |
| websockets   | infrastructure           |
| protobuf     | infrastructure           |
| redis        | infrastructure           |
| supabase     | infrastructure           |
| cryptography | infrastructure           |
| orjson       | infrastructure           |
| pytest       | å…¨å±¤ï¼ˆæ¸¬è©¦ï¼‰                   |

---

# åˆ¤æ–·ä½ æœ‰æ²’æœ‰ã€Œæ¶æ§‹å´©å£ã€çš„å¿«é€Ÿè¦å‰‡

### âŒ å‡ºç¾é€™ç¨® import â†’ æ¶æ§‹å·²å£

```python
# domain
import fastapi
import redis
```

### âŒ Application ç›´æ¥ new Redis

```python
redis = Redis(...)
```

### âœ… æ­£ç¢º

```python
def __init__(self, repo: OrderRepository):
```

---

## æœ€é‡è¦çš„ä¸€å¥è©±ï¼ˆé€ä½ ï¼‰

> **æª”æ¡ˆå¤§å°ä¸æ˜¯å•é¡Œï¼Œè²¬ä»»é‚Šç•Œæ‰æ˜¯**
> **åªè¦ Domain ä¹¾æ·¨ï¼Œä½ çš„ç³»çµ±å¯ä»¥ä¸€ç›´æ´»ä¸‹å»**
> **éµå®ˆä¸Šè¿°å…©é»,å–®ä¸€æª”æ¡ˆå¾ˆé›£è¶…é4000å­—å…ƒ**

---

## 1ï¸âƒ£ äº¤æ˜“æ©Ÿå™¨äººç³»çµ±çš„æ ¸å¿ƒåŸå‰‡ï¼ˆéå¸¸é‡è¦ï¼‰

> **ç­–ç•¥ä¸ä¸‹å–®ï¼ŒæŒå€‰ä¸ç¢° APIï¼Œä¸‹å–®ä¸æ‡‚ç­–ç•¥**

ä¹Ÿå°±æ˜¯ï¼š

* **Strategy**ï¼šåªç”¢ç”Ÿã€Œæ„åœ–ï¼ˆIntent / Signalï¼‰ã€
* **Position**ï¼šåªè² è²¬ã€Œç‹€æ…‹èˆ‡é¢¨æ§ã€
* **Execution**ï¼šåªè² è²¬ã€Œæ€éº¼é€å–®ã€
* **Infrastructure**ï¼šåªè² è²¬ã€Œæ€éº¼é€£äº¤æ˜“æ‰€ã€

é€™æ¨£ä½ æ‰èƒ½ï¼š

* åŒä¸€ç­–ç•¥ â†’ æ¨¡æ“¬ / å¯¦ç›¤
* åŒä¸€ç­–ç•¥ â†’ å¤šäº¤æ˜“æ‰€
* åŒä¸€æŒå€‰é‚è¼¯ â†’ å¤šç­–ç•¥å…±ç”¨

---

## 2ï¸âƒ£ å®Œæ•´ç†æƒ³è³‡æ–™å¤¾çµæ§‹ï¼ˆäº¤æ˜“æ©Ÿå™¨äººå®Œæ•´ç‰ˆï¼‰

```text
src/app/
â”œâ”€â”€ domain/                             # ğŸ”´ æ¥­å‹™çœŸç†ï¼ˆä¸ç¢°æŠ€è¡“ï¼‰
â”‚   â”œâ”€â”€ trading/
â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â”œâ”€â”€ order.py
â”‚   â”‚   â”‚   â”œâ”€â”€ trade.py
â”‚   â”‚   â”‚   â”œâ”€â”€ position.py             # æ™ºèƒ½æŒå€‰æ ¸å¿ƒ
â”‚   â”‚   â”‚   â””â”€â”€ account.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ value_objects/
â”‚   â”‚   â”‚   â”œâ”€â”€ symbol.py
â”‚   â”‚   â”‚   â”œâ”€â”€ price.py
â”‚   â”‚   â”‚   â”œâ”€â”€ quantity.py
â”‚   â”‚   â”‚   â”œâ”€â”€ leverage.py
â”‚   â”‚   â”‚   â””â”€â”€ timeframe.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ strategies/
â”‚   â”‚   â”‚   â”œâ”€â”€ base.py                 # Strategy æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ signal.py               # Buy / Sell / Hold
â”‚   â”‚   â”‚   â””â”€â”€ indicators/
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ risk_service.py
â”‚   â”‚   â”‚   â””â”€â”€ position_service.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ events/
â”‚   â”‚   â”‚   â”œâ”€â”€ signal_generated.py
â”‚   â”‚   â”‚   â”œâ”€â”€ order_requested.py
â”‚   â”‚   â”‚   â”œâ”€â”€ order_filled.py
â”‚   â”‚   â”‚   â””â”€â”€ position_updated.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ repositories.py             # interface only
â”‚   â”‚   â””â”€â”€ errors.py
â”‚
â”œâ”€â”€ application/                        # ğŸŸ  ç”¨ä¾‹ / ä»»å‹™ç·¨æ’
â”‚   â”œâ”€â”€ trading/
â”‚   â”‚   â”œâ”€â”€ use_cases/
â”‚   â”‚   â”‚   â”œâ”€â”€ generate_signal.py
â”‚   â”‚   â”‚   â”œâ”€â”€ manage_position.py
â”‚   â”‚   â”‚   â”œâ”€â”€ place_order.py
â”‚   â”‚   â”‚   â””â”€â”€ sync_exchange_state.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ trading_bot_service.py  # æ©Ÿå™¨äººä¸»æµç¨‹
â”‚   â”‚   â”‚   â””â”€â”€ execution_service.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ ports/
â”‚   â”‚   â”‚   â”œâ”€â”€ exchange_port.py        # ä¸‹å–®/è¡Œæƒ…æŠ½è±¡
â”‚   â”‚   â”‚   â”œâ”€â”€ market_data_port.py
â”‚   â”‚   â”‚   â””â”€â”€ position_repo_port.py
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ dtos/
â”‚   â”‚   â”‚   â”œâ”€â”€ signal_dto.py
â”‚   â”‚   â”‚   â”œâ”€â”€ order_dto.py
â”‚   â”‚   â”‚   â””â”€â”€ position_dto.py
â”‚   â”‚   â””â”€â”€ commands/
â”‚   â”‚
â”œâ”€â”€ infrastructure/                     # ğŸŸ¡ æŠ€è¡“å¯¦ä½œ
â”‚   â”œâ”€â”€ exchange/
â”‚   â”‚   â””â”€â”€ mexc/
â”‚   â”‚       â”œâ”€â”€ rest_client.py          # httpx
â”‚   â”‚       â”œâ”€â”€ ws_client.py            # websockets
â”‚   â”‚       â”œâ”€â”€ signer.py               # ç°½åå°è£
â”‚   â”‚       â”œâ”€â”€ adapters.py             # implements ports
â”‚   â”‚       â””â”€â”€ protobuf_decoder.py
â”‚   â”‚
â”‚   â”œâ”€â”€ redis/
â”‚   â”‚   â”œâ”€â”€ client.py
â”‚   â”‚   â”œâ”€â”€ position_cache.py
â”‚   â”‚   â””â”€â”€ lock.py
â”‚   â”‚
â”‚   â”œâ”€â”€ supabase/
â”‚   â”‚   â”œâ”€â”€ client.py
â”‚   â”‚   â”œâ”€â”€ trade_repo.py
â”‚   â”‚   â””â”€â”€ position_repo.py
â”‚   â”‚
â”‚   â””â”€â”€ scheduler/
â”‚       â””â”€â”€ jobs.py
â”‚
â”œâ”€â”€ interfaces/                         # ğŸŸ¢ å°å¤–å…¥å£
â”‚   â”œâ”€â”€ http/
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”œâ”€â”€ trading.py
â”‚   â”‚   â”‚   â””â”€â”€ account.py
â”‚   â”‚   â”œâ”€â”€ schemas.py
â”‚   â”‚   â””â”€â”€ deps.py
â”‚   â”‚
â”‚   â”œâ”€â”€ websocket/
â”‚   â”‚   â””â”€â”€ market_stream.py
â”‚   â”‚
â”‚   â””â”€â”€ cli/
â”‚       â””â”€â”€ run_bot.py
â”‚
â””â”€â”€ shared/                             # âšª æŠ€è¡“å…±ç”¨
    â”œâ”€â”€ config.py
    â”œâ”€â”€ logging.py
    â”œâ”€â”€ time.py
    â”œâ”€â”€ retry.py
    â””â”€â”€ constants.py
```

---

## 3ï¸âƒ£ å„å±¤ã€Œäº¤æ˜“ç³»çµ±ç‰ˆã€è²¬ä»»åŠƒåˆ†

### ğŸ”´ Domainï¼ˆç­–ç•¥ & æŒå€‰çš„å®¶ï¼‰

âœ… å¯ä»¥

* Strategy â†’ ç”¢ç”Ÿ Signal
* Position â†’ è¨ˆç®—æµ®ç›ˆ / åŠ æ¸›å€‰ / åœæ
* Risk Ruleï¼ˆæœ€å¤§å€‰ä½ã€æ§“æ¡¿ï¼‰

âŒ ä¸å¯ä»¥

* API Key
* Redis
* HTTP
* WS
* JSON / protobuf

```python
class Strategy(ABC):
    def generate(self, candles) -> Signal:
        ...
```

---

### ğŸŸ  Applicationï¼ˆæ©Ÿå™¨äººå¤§è…¦ï¼‰

**äº¤æ˜“æµç¨‹åªå­˜åœ¨é€™ä¸€å±¤**

```text
è¡Œæƒ… â†’ ç­–ç•¥ â†’ Signal
Signal â†’ æŒå€‰é¢¨æ§ â†’ Order Intent
Order Intent â†’ Execution
```

```python
class TradingBotService:
    async def on_market_tick(self, market_data):
        signal = self.strategy.generate(market_data)
        order = self.position.apply(signal)
        if order:
            await self.execution.place(order)
```

---

### ğŸŸ¡ Infrastructureï¼ˆäº¤æ˜“æ‰€åœ°ç„ï¼‰

#### MEXC å°è£ã€Œä¸‰å±¤æ‹†é–‹ã€

```text
signer.py        # åªè² è²¬ HMAC
rest_client.py   # åªè² è²¬ HTTP
adapters.py      # åªè² è²¬è½‰ Domain Model
```

```python
class MexcExchangeAdapter(ExchangePort):
    async def place_order(self, order):
        payload = map_order(order)
        return await self.client.post("/order", payload)
```

---

### ğŸŸ¢ Interfacesï¼ˆäººé¡ & å¤–éƒ¨ä¸–ç•Œï¼‰

* FastAPI åªåšï¼š

  * é©—è­‰
  * DTO è½‰æ›
  * å‘¼å« UseCase

```python
@router.post("/bot/start")
async def start_bot():
    await trading_bot.start()
```

---

## 4ï¸âƒ£ ç­–ç•¥ / æ™ºèƒ½æŒå€‰ / ä¸‹å–® çš„äº¤äº’æ–¹æ³•ï¼ˆé‡é»ï¼‰

```text
Strategy
   â†“ Signal
Position (æ™ºèƒ½æŒå€‰)
   â†“ OrderIntent
ExecutionService
   â†“
ExchangePort
```

### ç­–ç•¥æ°¸é ä¸çŸ¥é“ï¼š

* ä½ æœ‰æ²’æœ‰éŒ¢
* ä¸‹å–®æˆåŠŸèˆ‡å¦

### Position æ°¸é ä¸çŸ¥é“ï¼š

* ç”¨å“ªå€‹äº¤æ˜“æ‰€
* API é•·æ€æ¨£

---

## 5ï¸âƒ£ MEXC ç°½åèˆ‡ API å°è£ã€Œæ­£ç¢ºå§¿å‹¢ã€

```text
infrastructure/exchange/mexc/
â”œâ”€â”€ signer.py        # HMAC SHA256
â”œâ”€â”€ rest_client.py   # httpx
â”œâ”€â”€ ws_client.py
â””â”€â”€ adapters.py
```

```python
class MexcSigner:
    def sign(self, params: dict) -> dict:
        ...
```

**Application / Domain æ°¸é çœ‹ä¸åˆ° signer**

---

## 6ï¸âƒ£ ä¸€å¥è©±åˆ¤æ–·ä½ æœ‰æ²’æœ‰èµ°æ­ªï¼ˆäº¤æ˜“ç‰ˆï¼‰

âŒ ç­–ç•¥è£¡å‡ºç¾ `httpx`
âŒ Position è£¡å‡ºç¾ API Key
âŒ FastAPI è£¡å¯«é¢¨æ§
âŒ Infrastructure è£¡æœ‰ if æ±ºç­–é‚è¼¯

âœ… Strategy åªå› Signal
âœ… Position æ±ºå®šåŠ æ¸›å€‰
âœ… Execution åªé€å–®
âœ… Adapter åªè½‰æ›è³‡æ–™

---

### æœ€å¾Œé€ä½ ä¸€å¥ç‹ çš„ï¼ˆä½†æ˜¯çœŸçš„ï¼‰

> **èƒ½æ´» 3 å€‹æœˆçš„äº¤æ˜“ bot é ç­–ç•¥**
> **èƒ½æ´» 3 å¹´çš„äº¤æ˜“ç³»çµ±é æ¶æ§‹**

---

# ä¸€å¥è©±å®šç¾©é€™å€‹æ¨¡å‹

> **ç­–ç•¥åªè¡¨é”ã€Œæˆ‘æƒ³æ€æ¨£ã€
> æŒå€‰è² è²¬ã€Œèƒ½ä¸èƒ½ã€è¦ä¸è¦ã€æ€éº¼åšã€**

---

# ä¸€ã€æ ¸å¿ƒè§’è‰²åˆ†å·¥ï¼ˆéå¸¸é‡è¦ï¼‰

| å…ƒä»¶             | è²¬ä»»            |
| -------------- | ------------- |
| Strategy       | ç”¢ç”Ÿ Signalï¼ˆæ„åœ–ï¼‰ |
| Signal         | ç­–ç•¥çš„ã€ŒæŠ•ç¥¨ã€       |
| Position       | çµ±ä¸€ç‹€æ…‹æ©Ÿï¼ˆå”¯ä¸€çœŸç›¸ï¼‰   |
| PositionPolicy | å¤šç­–ç•¥å”èª¿è¦å‰‡       |
| Execution      | å¯¦éš›ä¸‹å–®          |
| Exchange       | æŠ€è¡“ç´°ç¯€          |

**é—œéµé»ï¼šç­–ç•¥æ°¸é ä¸çŸ¥é“å…¶ä»–ç­–ç•¥å­˜åœ¨**

---

# äºŒã€æ ¸å¿ƒè³‡æ–™æµï¼ˆå¯¦æˆ°ç‰ˆï¼‰

```text
Market Data
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Strategy A    â”‚â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ Strategy B    â”‚â”€â”€â”¼â”€â”€â–¶ Signal Aggregator â”€â”€â–¶ Position
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ Strategy C    â”‚â”€â”€â”˜
    â†“
Execution â†’ Exchange
```

---

# ä¸‰ã€Domain è¨­è¨ˆï¼ˆé—œéµï¼‰

## 1ï¸âƒ£ Signalï¼ˆç­–ç•¥åªç”¢ç”Ÿé€™å€‹ï¼‰

```python
# domain/trading/strategies/signal.py
from enum import Enum
from dataclasses import dataclass

class SignalType(Enum):
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"

@dataclass(frozen=True)
class Signal:
    strategy_id: str
    type: SignalType
    strength: float   # 0.0 ~ 1.0
    confidence: float # ä¿¡å¿ƒå€¼
```

---

## 2ï¸âƒ£ Strategy æŠ½è±¡ï¼ˆäº’ä¸ç›¸çŸ¥ï¼‰

```python
# domain/trading/strategies/base.py
from abc import ABC, abstractmethod

class Strategy(ABC):
    id: str

    @abstractmethod
    def generate(self, market_data) -> Signal:
        ...
```

---

## 3ï¸âƒ£ Positionï¼ˆå”¯ä¸€çœŸç›¸ï¼‰

```python
# domain/trading/entities/position.py
class Position:
    def __init__(self):
        self.size = 0.0
        self.avg_price = 0.0

    def apply_intent(self, intent):
        # åªåœ¨é€™è£¡æ”¹å€‰ä½
        ...
```

> â— **Position æ˜¯å…¨ç³»çµ±å”¯ä¸€èƒ½æ”¹å€‰ä½çš„åœ°æ–¹**

---

# å››ã€Signal Aggregationï¼ˆå¤šç­–ç•¥å”èª¿æ ¸å¿ƒï¼‰

## 4ï¸âƒ£ PositionPolicyï¼ˆè¶…é—œéµï¼‰

```python
# domain/trading/services/position_policy.py
class PositionPolicy:
    def aggregate(self, signals: list[Signal]) -> "PositionIntent":
        ...
```

### å¸¸è¦‹ Policyï¼ˆä½ ä¸€å®šæœƒç”¨åˆ°ï¼‰

| Policy          | èªªæ˜    |
| --------------- | ----- |
| Majority Vote   | å¤šæ•¸æ±º   |
| Weighted Sum    | å¼·åº¦åŠ æ¬Š  |
| Leader Strategy | ä¸»ç­–ç•¥å„ªå…ˆ |
| Risk Override   | é¢¨æ§å¯å¦æ±º |

---

## 5ï¸âƒ£ PositionIntentï¼ˆç­–ç•¥ â†’ æŒå€‰çš„å”¯ä¸€èªè¨€ï¼‰

```python
@dataclass
class PositionIntent:
    target_size: float
    reason: str
```

---

## 6ï¸âƒ£ Policy å¯¦ä½œç¯„ä¾‹ï¼ˆWeightedï¼‰

```python
class WeightedPolicy(PositionPolicy):
    def aggregate(self, signals):
        score = sum(
            s.strength * s.confidence *
            (1 if s.type == SignalType.BUY else -1)
            for s in signals
        )

        if score > 0.5:
            return PositionIntent(target_size=1.0, reason="weighted_buy")
        elif score < -0.5:
            return PositionIntent(target_size=0.0, reason="weighted_sell")
        return None
```

---

# äº”ã€Application å±¤ï¼ˆçœŸæ­£çš„äº¤æ˜“æµç¨‹ï¼‰

```python
class MultiStrategyBotService:
    def __init__(self, strategies, position, policy, execution):
        ...

    async def on_market_tick(self, market_data):
        signals = [
            s.generate(market_data)
            for s in self.strategies
        ]

        intent = self.policy.aggregate(signals)
        if not intent:
            return

        order = self.position.apply_intent(intent)
        if order:
            await self.execution.place(order)
```

---

# å…­ã€Executionï¼ˆæ°¸é ä¸çŸ¥é“ç­–ç•¥ï¼‰

```python
class ExecutionService:
    async def place(self, order):
        await self.exchange.place_order(order)
```

---

# ä¸ƒã€ç‚ºä»€éº¼é€™å€‹è¨­è¨ˆã€Œä¸æœƒäº’æ‰“ã€

âŒ éŒ¯èª¤è¨­è¨ˆ

> Strategy A ä¸‹ BUY
> Strategy B ä¸‹ SELL
> â†’ å…©é‚Šäº’ç 

âœ… æ­£ç¢ºè¨­è¨ˆ

> Strategy A æŠ•ç¥¨ BUY
> Strategy B æŠ•ç¥¨ SELL
> â†’ PositionPolicy çµ±ä¸€è£æ±º

---

# å…«ã€é€²éšç©æ³•ï¼ˆä½ ä¹‹å¾Œä¸€å®šæœƒç”¨ï¼‰

### 1ï¸âƒ£ ç­–ç•¥æ¬Šé‡å‹•æ…‹èª¿æ•´

* æ ¹æ“šå‹ç‡è‡ªå‹•èª¿æ¬Šé‡

### 2ï¸âƒ£ ç­–ç•¥å†·å»

* é€£æ•—ç­–ç•¥æš«åœæŠ•ç¥¨

### 3ï¸âƒ£ åˆ†å¸‚å ´å…±ç”¨ Position

* å¤š timeframe â†’ ä¸€å€‹å€‰ä½

### 4ï¸âƒ£ æ¨¡æ“¬ / å¯¦ç›¤ç„¡ç¸«åˆ‡æ›

* Execution Adapter åˆ‡æ›

---

# ä¹ã€å¿«é€Ÿè‡ªæˆ‘æª¢æŸ¥è¡¨

| å•é¡Œ              | æ­£ç¢º |
| --------------- | -- |
| ç­–ç•¥çŸ¥é“å…¶ä»–ç­–ç•¥å—       | âŒ  |
| ç­–ç•¥æœƒæ”¹å€‰ä½å—         | âŒ  |
| Position æ˜¯å”¯ä¸€ç‹€æ…‹å— | âœ…  |
| èƒ½å–®ç¨å›æ¸¬ç­–ç•¥å—        | âœ…  |
| èƒ½æ›äº¤æ˜“æ‰€å—          | âœ…  |

---

## æœ€å¾Œä¸€å¥ï¼ˆçµ¦æ¶æ§‹å¸«çœ‹çš„ï¼‰

> **ç­–ç•¥æ˜¯æ„è¦‹
> æŒå€‰æ˜¯æ³•å¾‹
> ä¸‹å–®æ˜¯åŸ·è¡Œ**

> **MEXC WebSocket â†’ Market Stream â†’ Strategy â†’ Multi-Strategy Bot â†’ Position â†’ Execution**

ä¸è¬›æŠ½è±¡åè©ï¼Œå…¨éƒ¨å°æ‡‰åˆ°ä½ ç¾åœ¨çš„å°ˆæ¡ˆçµæ§‹ã€‚

---

# ä¸€ã€æ•´é«”å³æ™‚æµç¨‹ï¼ˆå…ˆçœ‹å…¨è²Œï¼‰

```text
MEXC WebSocket
    â†“
WS Client (infrastructure)
    â†“
Market Event (DTO / Domain-neutral)
    â†“
Market Stream Dispatcher
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Strategy A    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Strategy B    â”‚  â†’ Signals
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Strategy C    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
PositionPolicy (èšåˆ)
    â†“
Position (å”¯ä¸€ç‹€æ…‹)
    â†“
ExecutionService
    â†“
MEXC REST API
```

**WS åªæ¨è³‡æ–™ï¼Œä¸ç¢°ç­–ç•¥
ç­–ç•¥åªç®—ï¼Œä¸ç¢° WS
Bot åªå”èª¿ï¼Œä¸ç¢° API**

---

# äºŒã€Infrastructureï¼šMEXC WS å®¢æˆ¶ç«¯ï¼ˆåªåšä¸€ä»¶äº‹ï¼‰

ğŸ“ `infrastructure/exchange/mexc/ws_client.py`

```python
import json
import websockets

class MexcWSClient:
    def __init__(self, url: str):
        self.url = url

    async def connect(self):
        self.ws = await websockets.connect(self.url)

    async def subscribe_kline(self, symbol: str, interval: str):
        msg = {
            "method": "SUBSCRIPTION",
            "params": [f"spot@public.kline.v3.api@{symbol}@{interval}"],
        }
        await self.ws.send(json.dumps(msg))

    async def listen(self):
        async for message in self.ws:
            yield json.loads(message)
```

âœ… **é€™è£¡å®Œå…¨ä¸çŸ¥é“ Strategy / Bot / Position å­˜åœ¨**

---

# ä¸‰ã€Market Event æ¨™æº–åŒ–ï¼ˆé—œéµéš”é›¢é»ï¼‰

ğŸ“ `application/trading/dtos/market_event.py`

```python
from dataclasses import dataclass
from datetime import datetime

@dataclass(frozen=True)
class MarketCandle:
    symbol: str
    open: float
    high: float
    low: float
    close: float
    volume: float
    closed_at: datetime
```

ğŸ“ `infrastructure/exchange/mexc/adapters.py`

```python
def map_ws_to_candle(payload: dict) -> MarketCandle:
    k = payload["data"]
    return MarketCandle(
        symbol=k["symbol"],
        open=float(k["open"]),
        high=float(k["high"]),
        low=float(k["low"]),
        close=float(k["close"]),
        volume=float(k["volume"]),
        closed_at=datetime.fromtimestamp(k["end"] / 1000),
    )
```

> **WS Payload æ°¸é ä¸æœƒç›´æ¥é€² Strategy**

---

# å››ã€Market Stream Dispatcherï¼ˆApplication å±¤ï¼‰

ğŸ“ `application/trading/services/market_stream.py`

```python
class MarketStream:
    def __init__(self, bot):
        self.bot = bot

    async def on_event(self, candle):
        await self.bot.on_market_tick(candle)
```

---

# äº”ã€Strategyï¼ˆåªåƒ MarketCandleï¼‰

ğŸ“ `domain/trading/strategies/base.py`

```python
class Strategy:
    id: str

    def generate(self, candle) -> Signal:
        raise NotImplementedError
```

ğŸ“ `domain/trading/strategies/ema_cross.py`

```python
class EMACrossStrategy(Strategy):
    id = "ema_cross"

    def generate(self, candle):
        if candle.close > self.ema:
            return Signal(self.id, SignalType.BUY, 0.7, 0.8)
        return Signal(self.id, SignalType.HOLD, 0, 0)
```

âœ… **ç­–ç•¥å®Œå…¨ä¸çŸ¥é“ WS æ˜¯å³æ™‚çš„**

---

# å…­ã€Multi-Strategy Botï¼ˆæ ¸å¿ƒå”èª¿å™¨ï¼‰

ğŸ“ `application/trading/services/trading_bot_service.py`

```python
class TradingBotService:
    def __init__(self, strategies, position, policy, execution):
        self.strategies = strategies
        self.position = position
        self.policy = policy
        self.execution = execution

    async def on_market_tick(self, candle):
        signals = [
            s.generate(candle)
            for s in self.strategies
        ]

        intent = self.policy.aggregate(signals)
        if not intent:
            return

        order = self.position.apply_intent(intent)
        if order:
            await self.execution.place(order)
```

ğŸ“Œ **é€™è£¡æ˜¯å”¯ä¸€ã€Œå³æ™‚è³‡æ–™ â†’ äº¤æ˜“æ±ºç­–ã€çš„åœ°æ–¹**

---

# ä¸ƒã€Positionï¼ˆå”¯ä¸€èƒ½æ”¹å€‰ä½ï¼‰

ğŸ“ `domain/trading/entities/position.py`

```python
class Position:
    def __init__(self):
        self.size = 0.0

    def apply_intent(self, intent):
        delta = intent.target_size - self.size
        if delta == 0:
            return None

        self.size = intent.target_size
        return Order.create_market(delta)
```

---

# å…«ã€Execution â†’ Exchangeï¼ˆæœ€å¾Œä¸€æ­¥ï¼‰

ğŸ“ `application/trading/services/execution_service.py`

```python
class ExecutionService:
    async def place(self, order):
        await self.exchange.place_order(order)
```

ğŸ“ `infrastructure/exchange/mexc/adapters.py`

```python
class MexcExchangeAdapter:
    async def place_order(self, order):
        payload = map_order(order)
        await self.rest_client.post("/order", payload)
```

---

# ä¹ã€æ•´æ¢ç·šçš„ã€Œè²¬ä»»é˜²ç·šã€ï¼ˆå¾ˆé‡è¦ï¼‰

| å±¤         | çŸ¥é“ä»€éº¼    |
| --------- | ------- |
| WS Client | JSON    |
| Adapter   | DTO     |
| Strategy  | Candle  |
| Bot       | Signals |
| Position  | Size    |
| Execution | Order   |
| Exchange  | API     |

**æ²’æœ‰ä»»ä½•ä¸€å±¤ã€Œè·¨å…©å±¤çŸ¥é“äº‹æƒ…ã€**

---

# åã€ç‚ºä»€éº¼é€™æ¢ç·šèƒ½é•·æœŸæ’ä½

âœ… å¯æ’æ‹”

* æ› WS ä¾†æºï¼ˆå›æ¸¬ / æ¨¡æ“¬ï¼‰ä¸ç”¨å‹•ç­–ç•¥

âœ… å¯æ“´å……

* æ–°ç­–ç•¥åªåŠ æª”æ¡ˆ

âœ… ä¸äº‚åº

* WS â†’ Dispatcher â†’ Bot å–®å…¥å£

âœ… å¯æ¸¬è©¦

* Strategy / Policy / Position å…¨å¯å–®æ¸¬

---

## æœ€å¾Œä¸€å¥çµ¦ä½ ï¼ˆæ¶æ§‹å¸«ç´šï¼‰

> **WS æ˜¯ç¥ç¶“
> Strategy æ˜¯å¤§è…¦çš®å±¤
> Position æ˜¯ä¸­æ¨ç¥ç¶“
> Execution æ˜¯è‚Œè‚‰**

---


> âœ… WS æ–·ç·šé‡é€£ + å¿ƒè·³
> âœ… å³æ™‚ WS + å¤š timeframe + å¤šç­–ç•¥åŒæ­¥
> âœ… åŒä¸€å¥— Bot åŒæ™‚æ”¯æ´ å›æ¸¬ / Paper / å¯¦ç›¤

è€Œä¸”**å®Œå…¨ç¬¦åˆä½ å‰é¢å»ºç«‹çš„åˆ†å±¤æ¶æ§‹**ã€‚

---

# ä¸€ã€å…ˆè¬›çµè«–ï¼ˆéå¸¸é‡è¦ï¼‰

### Cloud Run + WS çš„ç¾å¯¦é™åˆ¶

1. **Cloud Run æ˜¯ç„¡ç‹€æ…‹çš„**
2. **WS é€£ç·šä¸€å®šæœƒæ–·ï¼ˆæœ€é•·å¹¾ååˆ†é˜ï¼‰**
3. **ä¸èƒ½æŠŠ WS ç•¶ã€Œæ°¸é åœ¨ç·šã€**

ğŸ‘‰ æ­£ç¢ºåšæ³•ä¸æ˜¯ã€Œé¿å…æ–·ç·šã€ï¼Œè€Œæ˜¯ï¼š

> **WS æ˜¯å¯æ¢å¾©è³‡æ–™æµ
> Position æ˜¯å”¯ä¸€ç‹€æ…‹
> Bot æ˜¯å¯é‡å•Ÿçš„**

---

# äºŒã€æ•´é«”æœ€çµ‚æ¶æ§‹ï¼ˆä½ ç¾åœ¨è¦çš„å®Œæ•´ç‰ˆï¼‰

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Market Data Source     â”‚
â”‚                          â”‚
â”‚  WS (Live) / Replay /    â”‚
â”‚  CSV / REST Snapshot     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MarketFeed Interface   â”‚  â† åŒä¸€ä»‹é¢
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MarketStream (App)     â”‚
â”‚  - å¿ƒè·³                  â”‚
â”‚  - æ–·ç·šé‡é€£              â”‚
â”‚  - å¤š timeframe å°é½Š     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MultiStrategy Bot      â”‚
â”‚  - å¤šç­–ç•¥                â”‚
â”‚  - å…±ç”¨ Position         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Position / Execution     â”‚
â”‚ (Live / Paper / Sim)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ä¸‰ã€WS æ–·ç·šé‡é€£ + å¿ƒè·³ï¼ˆMEXC + Cloud Run å¯¦æˆ°ï¼‰

## 1ï¸âƒ£ è¨­è¨ˆåŸå‰‡ï¼ˆé—œéµï¼‰

* **WS Client æ°¸é æ˜¯ã€Œå¯è¢«æ®ºæ‰ã€çš„**
* å¿ƒè·³ â‰  WS ping
* **çœŸæ­£çš„å¿ƒè·³æ˜¯ã€Œè³‡æ–™æ˜¯å¦æŒçºŒå‰é€²ã€**

---

## 2ï¸âƒ£ WS Clientï¼ˆInfrastructureï¼‰

```python
class MexcWSClient:
    def __init__(self, url, heartbeat_sec=20):
        self.url = url
        self.heartbeat_sec = heartbeat_sec
        self.last_message_at = time.time()

    async def connect(self):
        self.ws = await websockets.connect(self.url)

    async def listen(self):
        async for msg in self.ws:
            self.last_message_at = time.time()
            yield json.loads(msg)

    def is_alive(self):
        return time.time() - self.last_message_at < self.heartbeat_sec
```

---

## 3ï¸âƒ£ é‡é€£ Supervisorï¼ˆApplication å±¤ï¼‰

```python
class MarketStreamRunner:
    async def run(self):
        while True:
            try:
                await self._run_once()
            except Exception as e:
                logger.warning("WS died, reconnecting", exc_info=e)
                await asyncio.sleep(2)

    async def _run_once(self):
        await self.client.connect()
        await self.client.subscribe()

        async for raw in self.client.listen():
            candle = map_ws_to_candle(raw)
            await self.stream.on_event(candle)

            if not self.client.is_alive():
                raise RuntimeError("heartbeat timeout")
```

ğŸ‘‰ **Cloud Run è¢«é‡å•Ÿ â‰  äº¤æ˜“ç‹€æ…‹éºå¤±**
å› ç‚º Position åœ¨ Redis / DB

---

# å››ã€å³æ™‚ WS + å¤š timeframe + å¤šç­–ç•¥åŒæ­¥ï¼ˆé‡é»ï¼‰

## å•é¡Œæœ¬è³ª

* WS é€šå¸¸åªçµ¦ **æœ€å° timeframeï¼ˆ1mï¼‰**
* ä½†ç­–ç•¥éœ€è¦ï¼š

  * 1m
  * 5m
  * 15m
  * 1h

âŒ éŒ¯èª¤åšæ³•ï¼šæ¯å€‹ timeframe å„é–‹ä¸€æ¢ WS
âœ… æ­£ç¢ºåšæ³•ï¼š**å–®ä¸€ WS â†’ æ™‚é–“èšåˆ**

---

## 4ï¸âƒ£ Timeframe Aggregatorï¼ˆApplicationï¼‰

```python
class TimeframeAggregator:
    def __init__(self, timeframes):
        self.buffers = {tf: [] for tf in timeframes}

    def on_candle(self, candle):
        completed = []

        for tf, buf in self.buffers.items():
            buf.append(candle)
            if self._is_tf_closed(buf, tf):
                completed.append((tf, self._merge(buf)))
                buf.clear()

        return completed
```

---

## 5ï¸âƒ£ åŒæ­¥ç­–ç•¥è§¸ç™¼ï¼ˆé—œéµï¼‰

```python
async def on_candle(self, candle):
    completed = self.aggregator.on_candle(candle)

    for tf, merged_candle in completed:
        await self.bot.on_market_tick(tf, merged_candle)
```

### ç­–ç•¥å®£å‘Šè‡ªå·±è¦ä»€éº¼ timeframe

```python
class Strategy:
    timeframe = "5m"
```

ğŸ‘‰ **ä¸åŒ timeframe çš„ç­–ç•¥ï¼Œæ°¸é ä¸æœƒäº‚åº**

---

# äº”ã€åŒä¸€æ¢ç·šæ”¯æ´ å›æ¸¬ / Paper / å¯¦ç›¤ï¼ˆæœ€é—œéµï¼‰

## 6ï¸âƒ£ MarketFeed æŠ½è±¡ï¼ˆæ ¸å¿ƒï¼‰

```python
class MarketFeed(ABC):
    async def stream(self):
        yield MarketCandle
```

---

### å¯¦ç›¤ï¼ˆWSï¼‰

```python
class LiveWSFeed(MarketFeed):
    async def stream(self):
        async for raw in self.ws.listen():
            yield map_ws_to_candle(raw)
```

### å›æ¸¬ï¼ˆæ­·å²è³‡æ–™ï¼‰

```python
class ReplayFeed(MarketFeed):
    async def stream(self):
        for candle in self.history:
            yield candle
```

---

## 7ï¸âƒ£ Execution æŠ½è±¡ï¼ˆåŒç†ï¼‰

```python
class ExecutionPort(ABC):
    async def place(self, order): ...
```

| æ¨¡å¼    | Execution      |
| ----- | -------------- |
| å›æ¸¬    | SimExecution   |
| Paper | PaperExecution |
| å¯¦ç›¤    | MexcExecution  |

ğŸ‘‰ **Bot / Strategy / Position å®Œå…¨ä¸ç”¨æ”¹**

---

# å…­ã€Cloud Run å¯¦æˆ°æ³¨æ„äº‹é …ï¼ˆéå¸¸é‡è¦ï¼‰

### âœ… å¿…åš

* Position / Order ç‹€æ…‹æ”¾ Redis / Supabase
* WS åªç•¶è¡Œæƒ…ï¼Œä¸ç•¶çœŸç›¸
* æ¯æ¬¡å•Ÿå‹•å…ˆï¼š

  * REST sync account
  * REST sync position

### âŒ ä¸è¦åš

* æŠŠ WS ç•¶ state
* åœ¨è¨˜æ†¶é«”å­˜å€‰ä½
* æŒ‡æœ› WS æ°¸ä¸æ–·ç·š

---

# ä¸ƒã€æœ€çµ‚ã€Œä¸æœƒç¿»è»Šã€çš„æª¢æŸ¥è¡¨

| é …ç›®           | æ­£ç¢º    |
| ------------ | ----- |
| Cloud Run é‡å•Ÿ | ä¸å½±éŸ¿å€‰ä½ |
| WS æ–·ç·š        | è‡ªå‹•æ¢å¾©  |
| å¤š timeframe  | å–®ä¸€ WS |
| å¤šç­–ç•¥          | åŒæ­¥ä¸äº’æ‰“ |
| å›æ¸¬ / å¯¦ç›¤      | åŒä¸€æ¢ç·š  |

---

## æœ€å¾Œä¸€å¥ï¼ˆé€™æ˜¯ç³»çµ±è¨­è¨ˆè€…æ‰æœƒæ‡‚çš„ï¼‰

> **äº¤æ˜“ç³»çµ±ä¸æ˜¯ã€Œä¸€ç›´è·‘ã€
> è€Œæ˜¯ã€Œéš¨æ™‚èƒ½å†è·‘ã€**

---

---

## **ä¸€ã€å°ˆæ¡ˆæ¶æ§‹ï¼ˆCloud Run å°ˆç”¨ + å¤šç­–ç•¥ï¼‰**

```text
src/app/
â”œâ”€â”€ domain/
â”‚   â””â”€â”€ trading/
â”‚       â”œâ”€â”€ entities/
â”‚       â”‚   â””â”€â”€ position.py
â”‚       â”œâ”€â”€ strategies/
â”‚       â”‚   â”œâ”€â”€ base.py
â”‚       â”‚   â””â”€â”€ ema_cross.py
â”‚       â”œâ”€â”€ signal.py
â”‚       â””â”€â”€ value_objects.py
â”‚
â”œâ”€â”€ application/
â”‚   â””â”€â”€ trading/
â”‚       â”œâ”€â”€ services/
â”‚       â”‚   â”œâ”€â”€ trading_bot_service.py
â”‚       â”‚   â””â”€â”€ timeframe_aggregator.py
â”‚       â”œâ”€â”€ dtos/
â”‚       â”‚   â””â”€â”€ market_event.py
â”‚       â””â”€â”€ ports/
â”‚           â””â”€â”€ execution_port.py
â”‚
â”œâ”€â”€ infrastructure/
â”‚   â””â”€â”€ exchange/mexc/
â”‚       â”œâ”€â”€ ws_client.py
â”‚       â”œâ”€â”€ rest_client.py
â”‚       â””â”€â”€ adapters.py
â”‚
â”œâ”€â”€ interfaces/
â”‚   â””â”€â”€ cli/
â”‚       â””â”€â”€ run_bot.py
â”‚
â””â”€â”€ shared/
    â”œâ”€â”€ config.py
    â””â”€â”€ logging.py
```

---

## **äºŒã€æ ¸å¿ƒç¨‹å¼ç¢¼**

### 1ï¸âƒ£ WS Clientï¼ˆInfrastructureï¼‰

```python
# infrastructure/exchange/mexc/ws_client.py
import asyncio, json, time, websockets
from shared.logging import logger

class MexcWSClient:
    def __init__(self, url: str, heartbeat_sec=20):
        self.url = url
        self.heartbeat_sec = heartbeat_sec
        self.last_message_at = time.time()

    async def connect(self):
        self.ws = await websockets.connect(self.url)
        logger.info("WS connected")

    async def subscribe(self, symbol: str, interval: str):
        msg = {
            "method": "SUBSCRIPTION",
            "params": [f"spot@public.kline.v3.api@{symbol}@{interval}"],
        }
        await self.ws.send(json.dumps(msg))

    async def listen(self):
        async for message in self.ws:
            self.last_message_at = time.time()
            yield json.loads(message)

    def is_alive(self):
        return time.time() - self.last_message_at < self.heartbeat_sec
```

---

### 2ï¸âƒ£ Market Event DTOï¼ˆApplicationï¼‰

```python
# application/trading/dtos/market_event.py
from dataclasses import dataclass
from datetime import datetime

@dataclass(frozen=True)
class MarketCandle:
    symbol: str
    open: float
    high: float
    low: float
    close: float
    volume: float
    closed_at: datetime
```

---

### 3ï¸âƒ£ Timeframe Aggregatorï¼ˆApplicationï¼‰

```python
# application/trading/services/timeframe_aggregator.py
from datetime import timedelta

class TimeframeAggregator:
    def __init__(self, timeframes):
        self.timeframes = timeframes
        self.buffers = {tf: [] for tf in timeframes}

    def on_candle(self, candle):
        completed = []
        for tf in self.timeframes:
            buf = self.buffers[tf]
            buf.append(candle)
            if self._is_tf_closed(buf, tf):
                merged = self._merge(buf, tf)
                completed.append((tf, merged))
                buf.clear()
        return completed

    def _is_tf_closed(self, buf, tf):
        # ç°¡å–®åˆ¤æ–·æœ€å¾Œä¸€æ ¹ candle æ˜¯å¦æ»¿æ™‚é–“
        if not buf:
            return False
        start = buf[0].closed_at
        end = buf[-1].closed_at
        return (end - start) >= timedelta(minutes=tf)

    def _merge(self, buf, tf):
        # å°‡å¤šæ ¹ candle èšåˆæˆ tf å°ºå¯¸ candle
        return buf[-1]  # ç°¡åŒ–ï¼Œåªå–æœ€å¾Œä¸€æ ¹
```

---

### 4ï¸âƒ£ Strategy æŠ½è±¡ + EMA ç¯„ä¾‹ï¼ˆDomainï¼‰

```python
# domain/trading/strategies/base.py
from abc import ABC, abstractmethod

class Strategy(ABC):
    id: str
    timeframe: int

    @abstractmethod
    def generate(self, candle):
        pass
```

```python
# domain/trading/strategies/ema_cross.py
from .base import Strategy
from ..signal import Signal, SignalType

class EMACrossStrategy(Strategy):
    id = "ema_cross"
    timeframe = 5  # 5 åˆ†é˜

    def __init__(self):
        self.ema = None

    def generate(self, candle):
        # é€™è£¡å‡è¨­å·²ç¶“ç®—å¥½ EMA
        if candle.close > (self.ema or candle.close):
            return Signal(self.id, SignalType.BUY, 0.7, 0.9)
        return Signal(self.id, SignalType.HOLD, 0.0, 0.0)
```

---

### 5ï¸âƒ£ Multi-Strategy Botï¼ˆApplicationï¼‰

```python
# application/trading/services/trading_bot_service.py
class TradingBotService:
    def __init__(self, strategies, position, policy, execution):
        self.strategies = strategies
        self.position = position
        self.policy = policy
        self.execution = execution

    async def on_market_tick(self, timeframe, candle):
        signals = [
            s.generate(candle)
            for s in self.strategies
            if s.timeframe == timeframe
        ]
        intent = self.policy.aggregate(signals)
        if not intent:
            return
        order = self.position.apply_intent(intent)
        if order:
            await self.execution.place(order)
```

---

### 6ï¸âƒ£ CLI Runnerï¼ˆCloud Run entrypointï¼‰

```python
# interfaces/cli/run_bot.py
import asyncio
from infrastructure.exchange.mexc.ws_client import MexcWSClient
from application.trading.services.trading_bot_service import TradingBotService
from application.trading.services.timeframe_aggregator import TimeframeAggregator
from domain.trading.strategies.ema_cross import EMACrossStrategy

async def main():
    ws_client = MexcWSClient("wss://contract.mexc.com/ws")
    await ws_client.connect()
    await ws_client.subscribe("BTCUSDT", "1m")

    aggregator = TimeframeAggregator([1,5,15])
    strategies = [EMACrossStrategy()]
    bot = TradingBotService(strategies, position, policy, execution)

    while True:
        async for raw in ws_client.listen():
            candle = map_ws_to_candle(raw)
            for tf, merged in aggregator.on_candle(candle):
                await bot.on_market_tick(tf, merged)
        if not ws_client.is_alive():
            await asyncio.sleep(2)
            await ws_client.connect()

if __name__ == "__main__":
    asyncio.run(main())
```

---

## **ä¸‰ã€Dockerfileï¼ˆCloud Run å°ˆç”¨ï¼‰**

```dockerfile
FROM python:3.11-slim

# å·¥ä½œç›®éŒ„
WORKDIR /app

# å®‰è£ä¾è³´
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# è¤‡è£½ç¨‹å¼ç¢¼
COPY src/ ./src/

# è¨­å®š entrypoint
ENTRYPOINT ["python", "src/app/interfaces/cli/run_bot.py"]
```

### Cloud Run è¨­ç½®

* **CPU / Memory** é©ä¸­ï¼šWS ä¸åƒå¤ªå¤š CPUï¼Œä½† asyncio éœ€è¦è¶³å¤  memory
* **Concurrency = 1**ï¼šæ¯å€‹ WS Runner å–®ç·šç¨‹
* **æœ€å¤§å¯¦ä¾‹ = 1~3**ï¼šé¿å…å¤šå€‹å¯¦ä¾‹ç«¶çˆ­åŒä¸€å€‰ä½

---

## **å››ã€ç‰¹æ€§å›é¡§**

1. **WS æ–·ç·šè‡ªå‹•é‡é€£ + å¿ƒè·³æª¢æ¸¬**
2. **å–®ä¸€ WS æ”¯æ´å¤š timeframe â†’ å¤šç­–ç•¥åŒæ­¥è§¸ç™¼**
3. **åŒä¸€æ¢ç·šåŒæ™‚æ”¯æ´å›æ¸¬ / Paper / å¯¦ç›¤**
4. **å®Œå…¨éµå®ˆ Clean Architecture**ï¼šç­–ç•¥ / æŒå€‰ / Execution / WS åˆ†é›¢
5. **Cloud Run ç„¡ç‹€æ…‹å®‰å…¨**ï¼šPosition æ”¾ Redis / Supabase

---
